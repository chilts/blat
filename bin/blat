#!/usr/bin/perl
## --------------------------------------------------------------------------------------------------------------------

use strict;
use warnings;
use Data::Dump qw(pp);
use Getopt::Mixed "nextOption";
use Config::Simple;
use File::Find;
use JSON::Any;
use File::Slurp;
use Template;
use Text::Markdown qw(markdown);
use Text::Textile qw(textile);
use HTML::Entities;

my $DEBUG = 0;
my $VERBOSE = 0;

## --------------------------------------------------------------------------------------------------------------------
# constants

use constant VERSION => '0.1';

## --------------------------------------------------------------------------------------------------------------------

{
    # get the input stuff
    my $opt = get_opt();
    my $cfg = get_cfg( $opt );

    for my $dir ( qw(src dest template) ) {
        $opt->{$dir} =~ s{ \/+ \z }{}gxms;
        debug( qq{opt{$dir}: $opt->{$dir}} );
    }
    debug( q{} );

    # find all the source files and split into 'pages' and 'data'
    my $site = get_files( $opt->{src} );

    # ToDo: make sure we have a .site.json file and all the .section.json files we need

    # set up the template
    my $template = Template->new({
        INCLUDE_PATH => $opt->{template},
    });

    # finally, loop through all the pages and template them in
    verbose( q{} );
    while ( my ($filename, $struct) = each %{$site->{page}} ) {
        # ToDo: should go up the levels, rather than just (site, section, file);
        # should be (site, parent sections..., section, file).

        $site->{site}{data} ||= {};
        $site->{section}{$struct->{dir}}{data} ||= {};

        # ToDo: need to change to inherit from multiple levels
        my $data = { %{$site->{site}{data}}, %{$site->{section}{$struct->{dir}}{data}}, %{$struct->{data}} };

        # read the file in, then process it
        my $raw = read_file( $struct->{fullname} );
        my $outfile;
        if ( $filename =~ m{\.html\z}xms ) {
            # just save as-is
            $data->{content} = $raw;
            $outfile = qq{$opt->{dest}/$struct->{dir}/$struct->{filename}};
        }
        elsif ( $filename =~ m{\.md\z}xms ) {
            # process as markdown
            $data->{content} = markdown( $raw );
            $outfile = qq{$opt->{dest}/$struct->{dir}/$struct->{filename}};
            $outfile =~ s{\.md\z}{.html}gxms;
        }
        elsif ( $filename =~ m{\.markdown\z}xms ) {
            # process as markdown
            $data->{content} = markdown( $raw );
            $outfile = qq{$opt->{dest}/$struct->{dir}/$struct->{filename}};
            $outfile =~ s{\.markdown\z}{.html}gxms;
        }
        elsif ( $filename =~ m{\.textile\z}xms ) {
            # process as markdown
            $data->{content} = textile( $raw );
            $outfile = qq{$opt->{dest}/$struct->{dir}/$struct->{filename}};
            $outfile =~ s{\.textile\z}{.html}gxms;
        }
        elsif ( $filename =~ m{\.txt\z}xms ) {
            # process as plain text
            $data->{content} = q{<pre>} . encode_entities($raw) . q{<pre>};
            $outfile = qq{$opt->{dest}/$struct->{dir}/$struct->{filename}};
            $outfile =~ s{\.txt\z}{.html}gxms;
        }
        else {
            # ToDo: WikiCreole?
            # ToDo: WikiFormat?
            print STDERR qq{Warning: unknown filetype, skipping};
            next;
        }

        # process this file
        my $output = '';
        my $template_data = {
            data => $data,
            blat => {
                # ToDo: this only copes with 1 level so far - make it more generic
                paths => [ $site->{section}{'.'}{data}, ( $struct->{dir} eq q{.} ? () : $site->{section}{$struct->{dir}}{data} ), $struct->{data} ],
            },
        };
        unless ( $template->process( $data->{template}, $template_data, \$output ) ) {
            print STDERR q{* something went wrong, skipping: } . $template->error() . qq{\n};
            next;
        }

        # write the output file
        verbose( qq{Written $outfile} );
        mkdir qq{$opt->{dest}/$struct->{dir}};
        write_file( $outfile, $output );
    }
}

## --------------------------------------------------------------------------------------------------------------------

sub get_files {
    my ($dir) = @_;

    my $file = {};

    find(
        sub {
            my ($cwd, $filename, $fullname) = ($File::Find::dir, $_, $File::Find::name);

            # if this isn't a regular file, skip it
            return if -d $filename;
            return if $filename eq q{.};
            unless ( -f $filename ) {
                print STDERR qq{Warning: not a regular file ($filename), skipping\n};
                return;
            };

            # remove the initial directory
            $cwd =~ s{\A$dir}{}gxms; # remove the initial dir
            $cwd =~ s{\A\/+}{}gxms; # remove leading slashes
            $cwd = '.' if $cwd eq ''; # make it '.' if nothing left

            # make the appropriate key for the $site->{page} hash
            my $key = length($cwd) ? qq{$cwd/$filename} : $filename;

            # figure out what we're looking at
            if ( $filename eq '.site.json' ) {
                # only save the site data file if it's in the top-level
                unless ( $cwd eq '.' ) {
                    print STDERR qq{Warning: Site file '$filename' ignored since not in top-level\n};
                    return;
                }

                # got the main .site.json file
                verbose( qq{Found site data: .site.json} );
                $file->{site} = {
                    dir      => $cwd,
                    filename => $filename,
                    fullname => $fullname,
                    data     => get_data( $filename ),
                }
            }
            elsif ( $filename eq '.section.json' ) {
                # a regular section data file
                verbose( qq{Found section data: $cwd/.section.json file} );
                $file->{section}{$cwd} = {
                    dir      => $cwd,
                    filename => $filename,
                    fullname => $fullname,
                    data     => get_data( $filename ),
                }
            }
            elsif ( $filename =~ m{\.json\z}xms ) {
                # if there is a file which corresponds with this one, save the data straight away
                my $other = substr($filename, 0, -5);
                unless ( -f $other ) {
                    print STDERR qq{Warning: Found .json file ($filename) which doesn't have a page file, skipping\n};
                    return;
                }
                verbose( qq{Found data: $cwd/$filename} );
                $file->{page}{qq{$cwd/$other}}{data} = get_data( $filename );
            }
            else {
                # make sure that a datafile is present for this content file
                unless ( -f qq{$filename.json} ) {
                    print STDERR qq{Error: found page file ($filename) with missing data file\n};
                    return;
                }

                verbose( qq{Found page: $cwd/$filename} );

                # save these separately (in case the $file->{page}{$key} already exists
                $file->{page}{$key}{dir} = $cwd;
                $file->{page}{$key}{filename} = $filename;
                $file->{page}{$key}{fullname} = $fullname;
            }
        },
        $dir
    );

    return $file;
}

sub get_data {
    my ($filename) = @_;
    return JSON::Any->jsonToObj( scalar read_file( $filename ) );
}

sub get_opt {
    my $opt = {};

    # all the long and short option names
    my @options = qw(
        src=s      s>src
        dest=s     d>dest
        template=s t>template
        filename   f>filename
        verbose    v>verbose
        debug
        help
        version
    );
    Getopt::Mixed::init( join(q{ }, @options) );

    # loop through all options
    while ( my ($name, $value) = nextOption() ) {
        $opt->{$name} = $value;
    }
    Getopt::Mixed::cleanup();

    # process the boolean options
    foreach my $name ( qw(verbose debug help version) ) {
        $opt->{$name} = exists $opt->{$name} ? 1 : 0;
    }

    # set some defaults
    $opt->{src} ||= q{src};
    $opt->{dest} ||= q{htdocs};
    $opt->{template} ||= q{tt};

    # set these globals
    $DEBUG = $opt->{debug};
    $VERBOSE = $opt->{verbose};

    return $opt;
}

sub get_cfg {
    my ($option) = @_;

    my $cfg = {};

    # so, read either the normal config or that defined on the command line
    my $filename = $option->{filename} || qq{.blatrc};
    Config::Simple->import_from( $filename, $cfg );

    return $cfg;
}

sub verbose {
    my ($msg) = @_;
    return unless $VERBOSE;
    print qq{$msg\n};
}

sub debug {
    my ($msg) = @_;
    return unless $DEBUG;
    print qq{$msg\n};
}

sub usage {
    my ($msg) = @_;
    if ( defined $msg ) {
        print qq{$msg\n\n};
    }

    print <<"EOF";
Usage: $0 <>

Options: ...

 -s, --src              the source directory (default: src)
 -d, --dest             the destination directory (default: htdocs)
 -t, --template         the template directory (default: tt)
     --version          version
     --help             help
     --verbose          verbose
     --debug            debug


EOF
}

## --------------------------------------------------------------------------------------------------------------------
